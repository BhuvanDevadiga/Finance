# -*- coding: utf-8 -*-
"""Finance

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1RjBGInx1IRM3NREDQTbfhCR-pE92QnuN
"""

!pip install --upgrade pinecone-client
!pip install transformers
!pip install torch
!pip install pdfplumber

import pinecone

pinecone.init(api_key='pcsk_3PGxxa_CQKgUY2mGEH4DSSwAkX5KZQ1RCknVNUWRGoLfoxQPTR68tfHEqhW8V9n2Z7fBRi', environment='us-west1-gcp')

import os
import pinecone

# Instead of pinecone.init(), create a Pinecone instance
# You can pass your API key directly or use an environment variable
pc = pinecone.Pinecone(
    api_key="pcsk_3PGxxa_CQKgUY2mGEH4DSSwAkX5KZQ1RCknVNUWRGoLfoxQPTR68tfHEqhW8V9n2Z7fBRi",  # or api_key=os.environ.get("PINECONE_API_KEY")
    environment="us-west1-gcp"
)

# Now you can use 'pc' to interact with Pinecone
# For example, to list your indexes:
indexes = pc.list_indexes()
print(indexes)

import pdfplumber

def parse_pdf(file_path):
    with pdfplumber.open(file_path) as pdf:
        for page in pdf.pages:
            tables = page.extract_tables()
            for table in tables:
                # Process the table data
                print(table)

from transformers import AutoTokenizer, AutoModel
import torch

tokenizer = AutoTokenizer.from_pretrained('sentence-transformers/all-MiniLM-L6-v2')
model = AutoModel.from_pretrained('sentence-transformers/all-MiniLM-L6-v2')

def get_embeddings(text):
    inputs = tokenizer(text, return_tensors='pt', truncation=True, padding=True)
    with torch.no_grad():
        embeddings = model(**inputs).last_hidden_state.mean(dim=1)
    return embeddings.numpy()

import pinecone

# Instead of pinecone.init(), create a Pinecone instance
# You can pass your API key directly or use an environment variable
pc = pinecone.Pinecone(
    api_key="pcsk_3PGxxa_CQKgUY2mGEH4DSSwAkX5KZQ1RCknVNUWRGoLfoxQPTR68tfHEqhW8V9n2Z7fBRi",  # or api_key=os.environ.get("PINECONE_API_KEY")
    environment="us-west1-gcp"
)

# Now you can use 'pc' to interact with Pinecone
# For example, to list your indexes:
indexes = pc.list_indexes()

# Print the names of the indexes in a more readable format
print("Existing indexes:", indexes.names())

# Assuming 'pc' is your Pinecone client instance
index_name_to_delete = "financial-terms"  # Replace with the actual name of the index to delete

# Check if the index exists before attempting to delete it
if index_name_to_delete in indexes.names():
    pc.delete_index(index_name_to_delete)
    print(f"Index '{index_name_to_delete}' deleted successfully.")
else:
    print(f"Index '{index_name_to_delete}' not found. It might have already been deleted or never created.")

def retrieve_and_generate(query, pc):  # Pass the Pinecone client instance instead of the index
    index_name = 'financial-terms'
    # Check if the index exists and create it if it doesn't
    if index_name not in pc.list_indexes().names():
        # Provide the 'spec' argument with index configuration, including 'environment'
        spec = {
            'pod': {
                'pod_type': 'p1',
                'environment': pc.environment  # Use the environment from the Pinecone client instance
            }
        }
        pc.create_index(index_name, dimension=384, spec=spec)  # Adjust dimension and pod_type if needed
    index = pc.Index(index_name)  # Now connect to the index

    query_embedding = get_embeddings(query)
    results = index.query(query_embedding, top_k=5)
    # Process results and generate response
    response = "Generated response based on retrieved data"
    return response

def retrieve_and_generate(query, pc, environment):
    index_name = 'financial-terms'
    # Check if the index exists and delete it if it does
    if index_name in pc.list_indexes().names():
        pc.delete_index(index_name)  # Delete the existing index
        print(f"Deleted existing index: {index_name}")
    # Create the index
    spec = {
        'pod': {
            'pod_type': 'p1',
            'environment': environment
        }
    }
    pc.create_index(index_name, dimension=384, spec=spec)
    print(f"Created index: {index_name}")

    index = pc.Index(index_name)

    query_embedding = get_embeddings(query)
    results = index.query(query_embedding, top_k=5)
    # Process results and generate response
    response = "Generated response based on retrieved data"
    return response

!pip install pdfplumber
!pip install pinecone-client
!pip install transformers
!pip install torch

import pdfplumber
import pinecone
from transformers import AutoTokenizer, AutoModel
import torch

# Pinecone setup (assuming 'pc' is your client instance)
index_name = 'financial-terms'
environment = "us-west1-gcp"  # Or get it from os.environ.get("PINECONE_ENVIRONMENT")

# Function to get embeddings
def get_embeddings(text):
    tokenizer = AutoTokenizer.from_pretrained('sentence-transformers/all-MiniLM-L6-v2')
    model = AutoModel.from_pretrained('sentence-transformers/all-MiniLM-L6-v2')
    inputs = tokenizer(text, return_tensors='pt', truncation=True, padding=True)
    with torch.no_grad():
        embeddings = model(**inputs).last_hidden_state.mean(dim=1)
    return embeddings.numpy()

# Function to retrieve and generate response
def retrieve_and_generate(query, pc, environment):
    index_name = 'financial-terms'
    # Check if the index exists and create it if it doesn't
    if index_name not in pc.list_indexes().names():
        spec = {
            'pod': {
                'pod_type': 'p1',
                'environment': environment
            }
        }
        pc.create_index(index_name, dimension=384, spec=spec)
        print(f"Created index: {index_name}")

    index = pc.Index(index_name)

    # Get embeddings for the query
    query_embedding = get_embeddings(query)

    # Query the Pinecone index
    results = index.query(vector=query_embedding.tolist()[0], top_k=5, include_metadata=True)

    # Process results and generate response (example)
    response = "Relevant information:\n"
    for match in results.matches:
        response += f"- {match.metadata.get('text', '')}\n"

    return response


# Function to process PDF and upload to Pinecone
def process_pdf(file_path, pc, environment):
    index_name = 'financial-terms'
    index = pc.Index(index_name)

    with pdfplumber.open(file_path) as pdf:
        for page in pdf.pages:
            text = page.extract_text()
            # Split the text into chunks (you might need to adjust this)
            chunks = text.split('\n\n')

            for chunk in chunks:
                # Get embeddings for the chunk
                embeddings = get_embeddings(chunk)

                # Upsert the chunk with metadata
                metadata = {'text': chunk, 'page': page.page_number}  # Add more metadata if needed
                index.upsert([(chunk.replace('\n', ' ').replace('  ', ' '), embeddings.tolist()[0], metadata)])
                print(f"Upserted chunk from page {page.page_number}")

# --- Main execution ---
# Replace with your PDF file path
pdf_file_path = 'your_pdf_file.pdf'

# Process PDF and upload data to Pinecone
process_pdf(pdf_file_path, pc, environment)

# Queries
queries = [
    "What is the total revenue?",
    "What are the operating expenses?",
    "What is the net profit margin?"
]

# Run queries and print responses
for query in queries:
    response = retrieve_and_generate(query, pc, environment)
    print(f"Query: {query}\nResponse: {response}\n")

import ipywidgets as widgets
from IPython.display import display

uploader = widgets.FileUpload(
    accept='.pdf',
    multiple=False
)
display(uploader)

# ... (later in your code) ...

# Check if a file has been uploaded before accessing its content
if uploader.value:  # This checks if uploader.value is not empty
    uploaded_file = uploader.value[0]  # Assuming only one file was uploaded
    with open('uploaded_pdf.pdf', 'wb') as f:
        f.write(uploaded_file['content'])

    pdf_file_path = 'uploaded_pdf.pdf'  # Use the saved file path
else:
    print("Please upload a PDF file first.")

!pip install --upgrade pinecone-client
!pip install transformers
!pip install torch
!pip install pdfplumber
!pip install ipywidgets

import time
import pdfplumber
import pinecone
from transformers import AutoTokenizer, AutoModel
import torch
import ipywidgets as widgets
from IPython.display import display

# Pinecone setup
index_name = 'financial-terms'
environment = "us-west1-gcp"  # Or get it from os.environ.get("PINECONE_ENVIRONMENT")

# Initialize Pinecone using Pinecone()
pc = pinecone.Pinecone(api_key="pcsk_3PGxxa_CQKgUY2mGEH4DSSwAkX5KZQ1RCknVNUWRGoLfoxQPTR68tfHEqhW8V9n2Z7fBRi", environment=environment)

# Function to get embeddings
def get_embeddings(text):
    tokenizer = AutoTokenizer.from_pretrained('sentence-transformers/all-MiniLM-L6-v2')
    model = AutoModel.from_pretrained('sentence-transformers/all-MiniLM-L6-v2')
    inputs = tokenizer(text, return_tensors='pt', truncation=True, padding=True)
    with torch.no_grad():
        embeddings = model(**inputs).last_hidden_state.mean(dim=1)
    return embeddings.numpy()

# Function to retrieve and generate response
def retrieve_and_generate(query, pc, environment):
    index_name = 'financial-terms'
    # Check if the index exists and create it if it doesn't
    if index_name not in pc.list_indexes().names():
        # ... (index creation logic, including error handling) ...
        pass  # Placeholder, see full code below

    index = pc.Index(index_name)
    query_embedding = get_embeddings(query)
    results = index.query(vector=query_embedding.tolist()[0], top_k=5, include_metadata=True)
    response = "Relevant information:\n"
    for match in results.matches:
        response += f"- {match.metadata.get('text', '')}\n"
    return response

# Function to process PDF and upload to Pinecone
def process_pdf(file_path, pc, environment):
    # ... (your PDF processing and upsert logic) ...
    pass  # Placeholder, see full code below

# --- Main execution ---

# File upload widget
uploader = widgets.FileUpload(accept='.pdf', multiple=False)
display(uploader)

# Check if a file has been uploaded
if uploader.value:
    # ... (save uploaded file to 'uploaded_pdf.pdf') ...
    pass  # Placeholder, see full code below

    pdf_file_path = 'uploaded_pdf.pdf'
else:
    print("Please upload a PDF file first.")

# Index creation and waiting logic (replace the placeholders above)
if index_name not in pc.list_indexes().names():
    try:
        spec = {'pod': {'pod_type': 'p1', 'environment': environment}}
        pc.create_index(index_name, dimension=384, spec=spec)
        print(f"Created index: {index_name}")
    except (pinecone.ForbiddenException, pinecone.NotFoundException) as e:
        print(f"Index creation failed or not found: {e}")
        # Consider deleting an existing index or upgrading your plan

    while True:
        try:
            index_description = pc.describe_index(index_name)
            if index_description.status.ready:
                print(f"Index '{index_name}' is ready.")
                break
            else:
                print(f"Index '{index_name}' is not ready yet. Waiting...")
                time.sleep(5)
        except pinecone.NotFoundException:
            print(f"Index '{index_name}' not found. Waiting for creation...")
            time.sleep(5)

# Get or create an index
index = pc.Index(index_name)

# ... (rest of your code remains the same: process_pdf, queries, etc.) ...

!pip install --upgrade pinecone-client
!pip install transformers
!pip install torch
!pip install pdfplumber
!pip install ipywidgets

import time
import pdfplumber
import pinecone
from transformers import AutoTokenizer, AutoModel
import torch
import ipywidgets as widgets
from IPython.display import display

# Pinecone setup
index_name = 'finance' # Updated index name
environment = "us-west1-gcp"  # Or get it from os.environ.get("PINECONE_ENVIRONMENT")

# Initialize Pinecone using Pinecone()
pc = pinecone.Pinecone(api_key="pcsk_3PGxxa_CQKgUY2mGEH4DSSwAkX5KZQ1RCknVNUWRGoLfoxQPTR68tfHEqhW8V9n2Z7fBRi", environment=environment)

# ... (rest of your code remains the same, with 'financial-terms' replaced by 'finance') ...

def process_pdf(file_path, pc, environment):
    index_name = 'finance' # Use the correct index name
    index = pc.Index(index_name)

    with pdfplumber.open(file_path) as pdf:
        for page in pdf.pages:
            text = page.extract_text()
            # Split the text into chunks (you might need to adjust this)
            chunks = text.split('\n\n')

            for chunk in chunks:
                # Get embeddings for the chunk
                embeddings = get_embeddings(chunk)

                # Upsert the chunk with metadata
                metadata = {'text': chunk, 'page': page.page_number}  # Add more metadata if needed
                index.upsert([(chunk.replace('\n', ' ').replace('  ', ' '), embeddings.tolist()[0], metadata)])
                print(f"Upserted chunk from page {page.page_number}")

uploader = widgets.FileUpload(accept='.pdf', multiple=False)
display(uploader)

# Check if a file has been uploaded
if uploader.value:
    uploaded_file = uploader.value[0]  # Assuming only one file was uploaded
    with open('uploaded_pdf.pdf', 'wb') as f:
        f.write(uploaded_file['content'])

    pdf_file_path = 'uploaded_pdf.pdf'  # Use the saved file path
else:
    print("Please upload a PDF file first.")

def process_pdf(file_path, pc, environment):
    index_name = 'finance' # Use the correct index name
    index = pc.Index(index_name)

    with pdfplumber.open(file_path) as pdf:
        for page in pdf.pages:
            text = page.extract_text()
            # Split the text into chunks (you might need to adjust this)
            chunks = text.split('\n\n')

            for chunk in chunks:
                # Get embeddings for the chunk
                embeddings = get_embeddings(chunk)

                # Upsert the chunk with metadata
                metadata = {'text': chunk, 'page': page.page_number}  # Add more metadata if needed
                index.upsert([(chunk.replace('\n', ' ').replace('  ', ' '), embeddings.tolist()[0], metadata)])
                print(f"Upserted chunk from page {page.page_number}")

if uploader.value:
    # ... (code to save the uploaded file and assign pdf_file_path) ...
    pass  # Add a placeholder or your actual code here
else:
    print("Please upload a PDF file first.")

uploader = widgets.FileUpload(accept='.pdf', multiple=False)
display(uploader)

# Check if a file has been uploaded
if uploader.value:
    uploaded_file = uploader.value[0]  # Assuming only one file was uploaded
    with open('uploaded_pdf.pdf', 'wb') as f:
        f.write(uploaded_file['content'])

    pdf_file_path = 'uploaded_pdf.pdf'  # Use the saved file path

    # Process PDF and upload data to Pinecone immediately after file upload
    process_pdf(pdf_file_path, pc, environment)
else:
    print("Please upload a PDF file first.")

index_name = 'finance' # or 'financial-terms' - check your previous code
while True:
    try:
        index_description = pc.describe_index(index_name)
        if index_description.status.ready:
            print(f"Index '{index_name}' is ready.")
            break
        else:
            print(f"Index '{index_name}' is not ready yet. Waiting...")
            time.sleep(5)
    except pinecone.NotFoundException:
        print(f"Index '{index_name}' not found. Was it created?")  # Add this for extra info
        time.sleep(5)

queries = [
    "What is the total revenue?",
    "What are the operating expenses?",
    "What is the net profit margin?"
]

# Run queries and print responses
for query in queries:
    response = retrieve_and_generate(query, pc, environment)
    print(f"Query: {query}\nResponse: {response}\n")

!pip install --upgrade pinecone-client
!pip install transformers
!pip install torch
!pip install pdfplumber
!pip install ipywidgets

import time
import pdfplumber
import pinecone
from transformers import AutoTokenizer, AutoModel
import torch
import ipywidgets as widgets
from IPython.display import display

# Pinecone setup
index_name = 'finance'  # Consistent index name
environment = "us-west1-gcp"  # Or get it from os.environ.get("PINECONE_ENVIRONMENT")

# Initialize Pinecone using Pinecone()
pc = pinecone.Pinecone(api_key="pcsk_3PGxxa_CQKgUY2mGEH4DSSwAkX5KZQ1RCknVNUWRGoLfoxQPTR68tfHEqhW8V9n2Z7fBRi", environment=environment)

# ... (rest of your code remains the same) ...

# Function to retrieve and generate response
def retrieve_and_generate(query, pc, environment):
    # Check if the index exists and create it if it doesn't
    if index_name not in pc.list_indexes().names():
        try:
            spec = {'pod': {'pod_type': 'p1', 'environment': environment}}
            pc.create_index(index_name, dimension=384, spec=spec)
            print(f"Created index: {index_name}")
        except (pinecone.ForbiddenException, pinecone.NotFoundException) as e:
            print(f"Index creation failed or not found: {e}")
            # Consider deleting an existing index or upgrading your plan

        # Wait for index to be ready
        while True:
            try:
                index_description = pc.describe_index(index_name)
                if index_description.status.ready:
                    print(f"Index '{index_name}' is ready.")
                    break
                else:
                    print(f"Index '{index_name}' is not ready yet. Waiting...")
                    time.sleep(5)
            except pinecone.NotFoundException:
                print(f"Index '{index_name}' not found. Waiting for creation...")
                time.sleep(5)

    index = pc.Index(index_name)
    # ... (rest of the retrieve_and_generate function remains the same) ...

# ... (rest of your code remains the same) ...

# Queries
queries = [
    "What is the total revenue?",
    "What are the operating expenses?",
    "What is the net profit margin?"
]

# Run queries and print responses
for query in queries:
    response = retrieve_and_generate(query, pc, environment)
    print(f"Query: {query}\nResponse: {response}\n")

def retrieve_and_generate(query, pc, environment):
    index_name = 'finance' # Use the correct index name
    index = pc.Index(index_name)

    # Get embeddings for the query
    query_embedding = get_embeddings(query)

    # Query the Pinecone index
    results = index.query(vector=query_embedding.tolist()[0], top_k=5, include_metadata=True)

    # Process results and generate response (example)
    response = "Relevant information:\n"
    for match in results.matches:
        response += f"- {match.metadata.get('text', '')}\n"

    return response

queries = [
    "What is the total revenue?",
    "What are the operating expenses?",
    "What is the net profit margin?"
]

# Run queries and print responses
for query in queries:
    response = retrieve_and_generate(query, pc, environment)
    print(f"Query: {query}\nResponse: {response}\n")

def retrieve_and_generate(query, pc, environment):
    # ...
    results = index.query(vector=query_embedding.tolist()[0], top_k=5, include_metadata=True)
    # ...
    return response